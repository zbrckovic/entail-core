{"version":3,"sources":["webpack://theoremCore/webpack/universalModuleDefinition","webpack://theoremCore/webpack/bootstrap","webpack://theoremCore/(webpack)/buildin/harmony-module.js","webpack://theoremCore/./src/abstract-structures/expression/error.ts","webpack://theoremCore/./src/abstract-structures/expression/expression-pointer.ts","webpack://theoremCore/./src/abstract-structures/expression/expression-util.ts","webpack://theoremCore/./src/abstract-structures/expression/expression.ts","webpack://theoremCore/./src/abstract-structures/expression/index.ts","webpack://theoremCore/./src/abstract-structures/sym/category.ts","webpack://theoremCore/./src/abstract-structures/sym/index.ts","webpack://theoremCore/./src/abstract-structures/sym/kind.ts","webpack://theoremCore/./src/abstract-structures/sym/sym.ts","webpack://theoremCore/./src/deduction-interface/deduction-interface.ts","webpack://theoremCore/./src/deduction-interface/error.ts","webpack://theoremCore/./src/deduction-interface/index.ts","webpack://theoremCore/./src/deduction-interface/rules-interface/deduction-rule-interface.ts","webpack://theoremCore/./src/deduction-interface/rules-interface/index.ts","webpack://theoremCore/./src/deduction-interface/rules-interface/premise-rule-interface.ts","webpack://theoremCore/./src/deduction-interface/rules-interface/quantification/existential-generalization-rule-interface.ts","webpack://theoremCore/./src/deduction-interface/rules-interface/quantification/existential-instantiation-rule-interface.ts","webpack://theoremCore/./src/deduction-interface/rules-interface/quantification/generalization-rule-interface.ts","webpack://theoremCore/./src/deduction-interface/rules-interface/quantification/index.ts","webpack://theoremCore/./src/deduction-interface/rules-interface/quantification/instantiation-rule-interface.ts","webpack://theoremCore/./src/deduction-interface/rules-interface/quantification/quantification-rule-interface.ts","webpack://theoremCore/./src/deduction-interface/rules-interface/quantification/universal-generalization-rule-interface.ts","webpack://theoremCore/./src/deduction-interface/rules-interface/quantification/universal-instantiation-rule-interface.ts","webpack://theoremCore/./src/deduction-interface/rules-interface/rules-interface.ts","webpack://theoremCore/./src/deduction-interface/rules-interface/tautological-implication-rule-interface.ts","webpack://theoremCore/./src/deduction-interface/rules-interface/theorem-rule-interface.ts","webpack://theoremCore/./src/deduction-structure/deduction.ts","webpack://theoremCore/./src/deduction-structure/index.ts","webpack://theoremCore/./src/deduction-structure/rule-application-spec/index.ts","webpack://theoremCore/./src/deduction-structure/rule-application-spec/regular-rule-application-spec.ts","webpack://theoremCore/./src/deduction-structure/rule-application-spec/theorem-rule-application-spec.ts","webpack://theoremCore/./src/deduction-structure/rule-application-summary/index.ts","webpack://theoremCore/./src/deduction-structure/rule-application-summary/regular-rule-application-summary.ts","webpack://theoremCore/./src/deduction-structure/rule-application-summary/theorem-rule-application-summary.ts","webpack://theoremCore/./src/deduction-structure/rule.ts","webpack://theoremCore/./src/deduction-structure/step.ts","webpack://theoremCore/./src/deduction-structure/term-dependency-graph/index.ts","webpack://theoremCore/./src/deduction-structure/term-dependency-graph/term-dependencies.ts","webpack://theoremCore/./src/deduction-structure/term-dependency-graph/term-dependency-graph.ts","webpack://theoremCore/./src/error.ts","webpack://theoremCore/./src/formula-construction-util.ts","webpack://theoremCore/./src/index.ts","webpack://theoremCore/./src/primitive-syms.ts","webpack://theoremCore/./src/propositional-logic/primitive-truth-functions.ts","webpack://theoremCore/./src/propositional-logic/propositional-logic-util.ts","webpack://theoremCore/./src/propositional-logic/propositional-logic.ts","webpack://theoremCore/./src/propositional-logic/reduce-to-truth-functional.ts","webpack://theoremCore/external {\"commonjs\":\"immutable\",\"commonjs2\":\"immutable\",\"amd\":\"immutable\"}"],"names":["ExpressionError","BaseError","ExpressionPointer","sym","isRoot","undefined","target","parentPointer","parent","boundSym","equals","position","findBindingOccurrence","findFreeOccurrences","map","concat","findBoundOccurrences","expression","getSubexpressionsOnPath","Set","withMutations","mutable","add","union","getBoundSyms","isEmpty","getSubexpression","CantGetParentOfRootError","update","butLast","Record","Expression","List","connectWithBinarySym","expressions","length","NotEnoughExpressionsError","first","second","rest","connect","children","of","reduce","i","child","get","NoChildAtIndexError","pos","getChild","slice","exp","replaceSubexpression","subexp","newSubexp","res","newSym","getBoundSym","updateSubexpression","newBoundSym","binds","newChildren","resolveChildren","mutableSubexp","set","mutableRes","push","resultsForChildren","flatMap","unshift","ExpressionDoesntBindError","childResult","acc","replaceSymAt","replaceBoundOccurrences","mutableSyms","forEach","getSyms","boundSyms","contains","getFreeSyms","filter","kind","Kind","Term","_findBoundSymsAtFreeOccurrencesOfSym","bound","result","oldSym","oldChildren","argumentKind","Error","Range","arity","toList","size","index","Category","precedence","FF","FT","TT","TF","order","c1","c2","Sym","Formula","id","getCategory","c","props","getKindsFromCategory","fromCategory","category","DeductionInterface","deduction","Deduction","indexes","createIndexes","RulesInterface","ordinals","stepOrdinalOutOfRange","find","ordinal","Number","isInteger","StepOrdinalOutOfRangeError","stepOrdinal","maxStepOrdinal","DeductionInterfaceError","DeductionRuleInterface","firstStepIndex","secondStepIndex","ruleApplicationSpec","RegularRuleApplicationSpec","getStep","formula","newDeduction","applyRule","PremiseRuleInterface","premise","ExistentialGeneralizationRuleInterface","newTerm","oldTerm","existentialGeneralization","stepIndex","GeneralizationRuleInterface","ExistentialInstantiationRuleInterface","existentialInstantiation","e","TermDependencyGraphTermAlreadyUsedError","TermAlreadyUsedError","term","TermDependencyGraphCyclicDependenciesError","TermsCyclicDependenciesError","dependentTerm","dependencyTerm","InstantiationRuleInterface","substitutionRequired","is","GeneralizedTermIllegallyBindsError","findBoundSymsAtFreeOccurrencesOfSym","GeneralizedTermBecomesIllegallyBoundError","concreteApply","InvalidSubstitutionResultError","firstBoundOccurrencePosition","shift","QuantificationRuleInterface","TermNotProvidedForNonVacuousQuantificationError","InstanceTermBecomesIllegallyBoundError","firstOccurrence","UniversalGeneralizationRuleInterface","universalGeneralization","UniversalInstantiationRuleInterface","universalInstantiation","steps","Rule","TautologicalImplication","TautologicalImplicationRuleInterface","Premise","Theorem","TheoremRuleInterface","step","universalQuantifier","UniversalInstantiation","existentialQuantifier","ExistentialInstantiation","UniversalGeneralization","ExistentialGeneralization","firstStep","secondStep","firstStepIsPremise","ruleApplicationSummary","rule","firstIsAssumptionForSecond","assumptions","stepIndexes","isLogicalConsequence","InvalidTautologicalImplicationError","tautologicalImplication","OrderedSet","consequence","join","applyTheoremRule","applyRegularRule","theorem","theoremId","TheoremRuleApplicationSummary","Step","addStep","premises","conclusion","termDependencies","assumptionToRemove","calculateAssumptions","RegularRuleApplicationSummary","graph","termDependencyGraph","updateGraph","setGraph","last","toRemove","toIndexedSeq","toSet","remove","dependent","dependencies","addDependencies","toArray","TermDependencyGraph","antecedent","antecedentIndex","consequent","consequentIndex","implication","premiseIndex","replaceFreeOccurrences","getFreeTerms","addDependency","TermDependencies","TheoremRuleApplicationSpec","RuleAbbreviation","getAbbreviation","ruleToAbbreviation","getRule","abbreviation","abbreviationToRule","P","D","TI","UI","UG","EI","EG","T","dependency","dependenciesSet","has","cycleInducingDependency","hasDependency","CyclicDependenciesError","normalize","values","entrySeq","_getDependents","traversed","directDependents","getDirectDependents","_getDependencies","directDependencies","_hasDependency","sym1Dependencies","some","normalizedDownwards","normalizeDownwards","furtherDependent","hasDirectDependency","removeDirectDependency","furtherDependency","dependencyTerms","newDependencyTerms","Map","TermDependencyGraphError","message","name","constructor","createConjunction","formulas","conjunction","createImplicationWithAntecedentsAsConjunction","antecedents","kita","module","exports","negation","ff","disjunction","equivalence","primitiveSyms","primitiveTruthFunctions","evaluate","interpretation","NotTruthFunctionalError","value","NoAssignedValueError","childrenValues","getTruthTable","findInterpretations","findInterpretationsLimitedByBaseInterpretation","fixedValue","tableValue","tableArgs","interpretations","findInterpretationsLimitedByBaseInterpretations","truthFunction","EvaluationError","isSatisfiable","hasInterpretations","isFalsifiable","isContingent","isTautology","isContradiction","reducedFormula","reduceToTruthFunctional","util","reduceToTruthFunctionalWithSubstitutions","substitutions","currentChildren","currentAssignments","newChild","newAssignments","assignmentsToReturn","substitutedSym"],"mappings":"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","file":"theoremCore.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"immutable\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"theoremCore\", [\"immutable\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"theoremCore\"] = factory(require(\"immutable\"));\n\telse\n\t\troot[\"theoremCore\"] = factory(root[undefined]);\n})(window, function(__WEBPACK_EXTERNAL_MODULE_immutable__) {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.ts\");\n","module.exports = function(originalModule) {\n\tif (!originalModule.webpackPolyfill) {\n\t\tvar module = Object.create(originalModule);\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"exports\", {\n\t\t\tenumerable: true\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n","import { BaseError } from '../../error'\r\n\r\nexport abstract class ExpressionError extends BaseError {\r\n}\r\n","import { List, Record, Set } from 'immutable'\r\nimport { Sym } from '../sym'\r\nimport { ExpressionError } from './error'\r\nimport { Expression, Position } from './expression'\r\n\r\n/**\r\n * Pointer to the specific subexpression of the base expression.\r\n *\r\n * Contains the base `expression` and the `position` which is a path to some subexpression. This\r\n * subexpression is called a 'target'.\r\n */\r\nexport class ExpressionPointer extends Record<{\r\n    expression: Expression\r\n    position: Position\r\n}>({\r\n    expression: new Expression(),\r\n    position: List()\r\n}, 'ExpressionPointer') {\r\n    get isRoot() { return this.position.isEmpty() }\r\n\r\n    get target() { return this.expression.getSubexpression(this.position) }\r\n\r\n    get parent(): ExpressionPointer {\r\n        if (this.isRoot) throw new CantGetParentOfRootError()\r\n\r\n        return this.update('position', position => position.butLast())\r\n    }\r\n\r\n    /**\r\n     * Return a path to the ancestor subexpression which binds `sym` at the target position.\r\n     *\r\n     * In other words, find the closest target's ancestor which has `sym` as its `boundSym`. If\r\n     * `sym` is not specified, `mainSym` at target is assumed.\r\n     */\r\n    findBindingOccurrence(sym?: Sym): Position | undefined {\r\n        if (this.isRoot) return undefined\r\n\r\n        sym = sym ?? this.target.sym\r\n\r\n        const parentPointer = this.parent\r\n        const { boundSym } = parentPointer.target\r\n\r\n        return boundSym?.equals(sym)\r\n            ? parentPointer.position\r\n            : parentPointer.findBindingOccurrence(sym)\r\n    }\r\n\r\n    findFreeOccurrences(sym: Sym): List<Position> {\r\n        return this\r\n            .target\r\n            .findFreeOccurrences(sym)\r\n            .map(position => this.position.concat(position))\r\n    }\r\n\r\n    findBoundOccurrences(): List<Position> {\r\n        return this\r\n            .target\r\n            .findBoundOccurrences()\r\n            .map(position => this.position.concat(position))\r\n    }\r\n\r\n    getSubexpressionsOnPath() {\r\n        return this.expression.getSubexpressionsOnPath(this.position)\r\n    }\r\n\r\n    /**\r\n     * Find all symbols which are bound by ancestors.\r\n     *\r\n     * It doesn't necessarily search for symbols which actually appear in the target. It\r\n     * searches for all symbols `S` which would be bound by some ancestor if we replaced the target\r\n     * with some formula containing `S` as free symbol.\r\n     */\r\n    getBoundSyms(): Set<Sym> {\r\n        if (this.isRoot) return Set()\r\n        const parent = this.parent\r\n        const boundSym = parent.target.boundSym\r\n        return Set()\r\n            .withMutations(mutable => { if (boundSym !== undefined) mutable.add(boundSym) })\r\n            .union(parent.getBoundSyms())\r\n    }\r\n}\r\n\r\nexport class CantGetParentOfRootError extends ExpressionError {}\r\n","import { List } from 'immutable'\r\nimport { Sym } from '../sym'\r\nimport { ExpressionError } from './error'\r\nimport { Expression } from './expression'\r\n\r\n/**\r\n * Reduce `expressions` to a single expression using binary connective. Reduction is performed from\r\n * left to right.\r\n *\r\n * From A, B, C we will get ((A, B), C), not (A, (B, C)).\r\n */\r\nexport const connectWithBinarySym = (expressions: Expression[], sym: Sym) => {\r\n    if (expressions.length < 2) throw new NotEnoughExpressionsError()\r\n    const [first, second, ...rest] = expressions\r\n\r\n    const connect = (first: Expression, second: Expression) => new Expression({\r\n        sym,\r\n        children: List.of(first, second)\r\n    })\r\n\r\n    return rest.reduce(connect, connect(first, second))\r\n}\r\n\r\nexport class NotEnoughExpressionsError extends ExpressionError {}\r\n","import { List, Range, Record, Set } from 'immutable'\r\nimport { Sym } from '../sym'\r\nimport { Kind } from '../sym/kind'\r\nimport { ExpressionError } from './error'\r\n\r\n/**\r\n * Abstract tree-like structure which is used to represents formulas and terms.\r\n */\r\nexport class Expression extends Record<{\r\n    /** Main symbol */\r\n    sym: Sym\r\n\r\n    /**\r\n     * Bound symbol\r\n     *\r\n     * In first-order logic this will always be nullary term (individual variable), but here we are\r\n     * at a higher level of abstraction and don't make this assumption.\r\n     */\r\n    boundSym?: Sym\r\n\r\n    children: List<Expression>\r\n}>({\r\n    sym: undefined!,\r\n    boundSym: undefined,\r\n    children: List()\r\n}, 'Expression') {\r\n    getChild(i: number): Expression {\r\n        const child = this.children.get(i)\r\n        if (child === undefined) throw new NoChildAtIndexError(this, i)\r\n        return child\r\n    }\r\n\r\n    getSubexpression(pos: Position): Expression {\r\n        return pos.isEmpty()\r\n            ? this\r\n            : this\r\n                .getChild(pos.first())\r\n                .getSubexpression(pos.slice(1))\r\n    }\r\n\r\n    replaceSubexpression(pos: Position, exp: Expression): Expression {\r\n        return pos.isEmpty()\r\n            ? exp\r\n            : this.update('children', children => children.update(\r\n                pos.first(),\r\n                child => child.replaceSubexpression(pos.slice(1), exp)\r\n            ))\r\n    }\r\n\r\n    updateSubexpression(pos: Position, update: (exp: Expression) => Expression) {\r\n        const subexp = this.getSubexpression(pos)\r\n        const newSubexp = update(subexp)\r\n        return this.replaceSubexpression(pos, newSubexp)\r\n    }\r\n\r\n    getSubexpressionsOnPath(pos: Position) {\r\n        let res = List.of<Expression>(this)\r\n        if (!pos.isEmpty()) {\r\n            const child = this.getChild(pos.first())\r\n            res = res.concat(child.getSubexpressionsOnPath(pos.slice(1)))\r\n        }\r\n        return res\r\n    }\r\n\r\n    replaceSymAt(\r\n        pos: Position,\r\n        newSym: Sym,\r\n        getBoundSym?: () => Sym | undefined,\r\n        getChild?: (i: number) => Expression\r\n    ) {\r\n        return this.updateSubexpression(pos, exp => {\r\n            const { sym, boundSym, children } = exp\r\n\r\n            const newBoundSym = newSym.binds ? boundSym ?? getBoundSym?.() : undefined\r\n            const newChildren = resolveChildren(sym, newSym, children, getChild)\r\n\r\n            return exp.withMutations(mutableSubexp => {\r\n                mutableSubexp.set('sym', newSym)\r\n                mutableSubexp.set('boundSym', newBoundSym)\r\n                mutableSubexp.set('children', newChildren)\r\n            })\r\n        })\r\n    }\r\n\r\n    findFreeOccurrences(sym: Sym) {\r\n        return List<Position>().withMutations(mutableRes => {\r\n            if (this.sym.equals(sym)) mutableRes.push(List())\r\n\r\n            if (!this.boundSym?.equals(sym)) {\r\n                const resultsForChildren = this.children.flatMap((child, i) =>\r\n                    child\r\n                        .findFreeOccurrences(sym)\r\n                        .map(position => position.unshift(i))\r\n                )\r\n                mutableRes.concat(resultsForChildren)\r\n            }\r\n        })\r\n    }\r\n\r\n    findBoundOccurrences(): List<Position> {\r\n        const boundSym = this.boundSym\r\n        if (boundSym === undefined) throw new ExpressionDoesntBindError(this)\r\n\r\n        return this.children.flatMap(\r\n            (child, i) =>\r\n                child\r\n                    .findFreeOccurrences(boundSym)\r\n                    .map(childResult => childResult.unshift(i))\r\n        )\r\n    }\r\n\r\n    replaceFreeOccurrences(\r\n        sym: Sym,\r\n        newSym: Sym,\r\n        getBoundSym?: (pos: Position) => Sym,\r\n        getChild?: (pos: Position) => Expression\r\n    ) {\r\n        return this\r\n            .findFreeOccurrences(sym)\r\n            .reduce((acc: Expression, position) => acc.replaceSymAt(\r\n                position,\r\n                newSym,\r\n                getBoundSym === undefined ? undefined : (): Sym => getBoundSym(position),\r\n                getChild === undefined ? undefined : (): Expression => getChild(position)\r\n            ), this)\r\n    }\r\n\r\n    replaceBoundOccurrences(newSym: Sym) {\r\n        return this\r\n            .findBoundOccurrences()\r\n            .reduce((acc: Expression, pos) => acc.replaceSymAt(pos, newSym), this)\r\n            .set('boundSym', newSym)\r\n    }\r\n\r\n    replaceBoundOccurrencesAt(pos: Position, newSym: Sym) {\r\n        return this.updateSubexpression(pos, exp => exp.replaceBoundOccurrences(newSym))\r\n    }\r\n\r\n    getSyms() {\r\n        return Set<Sym>().withMutations(mutableSyms => {\r\n            mutableSyms.add(this.sym)\r\n            if (this.boundSym !== undefined) mutableSyms.add(this.boundSym)\r\n            this.children.forEach(child => { mutableSyms.union(child.getSyms()) })\r\n        })\r\n    }\r\n\r\n    getFreeSyms(boundSyms = Set()) {\r\n        return Set<Sym>().withMutations(mutableSyms => {\r\n            if (!boundSyms.contains(this.sym)) mutableSyms.add(this.sym)\r\n            if (this.boundSym !== undefined) boundSyms = boundSyms.add(this.boundSym)\r\n            this.children.forEach(child => { mutableSyms.union(child.getFreeSyms(boundSyms)) })\r\n        })\r\n    }\r\n\r\n    getFreeTerms(boundSyms = Set()) {\r\n        return this.getFreeSyms(boundSyms).filter(sym => sym.kind === Kind.Term)\r\n    }\r\n\r\n    findBoundSymsAtFreeOccurrencesOfSym(sym: Sym): Set<Sym> {\r\n        return this._findBoundSymsAtFreeOccurrencesOfSym(sym)\r\n    }\r\n\r\n    private _findBoundSymsAtFreeOccurrencesOfSym(sym: Sym, bound = Set<Sym>()): Set<Sym> {\r\n        let result = Set<Sym>()\r\n\r\n        if (this.sym.equals(sym)) result = bound\r\n\r\n        if (this.boundSym !== undefined) {\r\n            if (this.boundSym.equals(sym)) return result\r\n            bound = bound.add(this.boundSym)\r\n        }\r\n\r\n        return this.children.reduce(\r\n            (acc, child) => acc.union(child._findBoundSymsAtFreeOccurrencesOfSym(sym, bound)),\r\n            result\r\n        )\r\n    }\r\n}\r\n\r\nconst resolveChildren = (\r\n    oldSym: Sym,\r\n    newSym: Sym,\r\n    oldChildren: List<Expression>,\r\n    getChild?: (i: number) => Expression\r\n) => {\r\n    if (oldSym.argumentKind !== newSym.argumentKind) {\r\n        if (getChild === undefined) throw new Error('getChild not present')\r\n        return Range(0, newSym.arity).map(getChild).toList()\r\n    }\r\n\r\n    if (oldChildren.size >= newSym.arity) {\r\n        return oldChildren.slice(0, newSym.arity)\r\n    } else {\r\n        if (getChild === undefined) throw new Error('getChild not present')\r\n        return oldChildren.concat(Range(oldChildren.size, newSym.arity).map(getChild))\r\n    }\r\n}\r\n\r\nexport class ExpressionDoesntBindError extends ExpressionError {\r\n    constructor(readonly expression: Expression) {\r\n        super(`expression ${expression} doesn't bind`)\r\n    }\r\n}\r\n\r\nexport class NoChildAtIndexError extends ExpressionError {\r\n    constructor(\r\n        readonly expression: Expression,\r\n        readonly index: number\r\n    ) {\r\n        super(`can't get child of ${expression} at index ${index}`)\r\n    }\r\n}\r\n\r\nexport type Position = List<number>\r\n","export * from './expression'\r\nexport * from './expression-pointer'\r\nexport * from './expression-util'\r\n","/**\r\n * Represents four possible categories of symbol depending on the kind of expression it forms and\r\n * the kind of expressions it accepts as arguments.\r\n */\r\nexport enum Category {\r\n    /**\r\n     * Forms `Formula`, accepts `Formula`.\r\n     *\r\n     * Truth-functional connective, propositional variable, propositional constant and quantifier.\r\n     */\r\n    FF = 'FF',\r\n    /**\r\n     * Forms `Formula`, accepts `Term`.\r\n     *\r\n     * Predicate.\r\n     */\r\n    FT = 'FT',\r\n    /**\r\n     * Forms `Term`, accepts `Term`.\r\n     *\r\n     * Individual variable and function variable.\r\n     */\r\n    TT = 'TT',\r\n    /**\r\n     * Forms `Term`, accepts `Formula`.\r\n     *\r\n     * Reserved for definite descriptions.\r\n     */\r\n    TF = 'TF',\r\n}\r\n\r\nconst precedence = {\r\n    [Category.FF]: 0,\r\n    [Category.FT]: 1,\r\n    [Category.TT]: 2,\r\n    [Category.TF]: 3\r\n}\r\n\r\nexport const order = (c1: Category, c2: Category) => precedence[c1] - precedence[c2]\r\n","export * from './sym'\r\n","/**\r\n * Represents two possible kinds of expressions.\r\n *\r\n * By extension `Sym` will also be of a specific kind depending on whether it forms a formula or a\r\n * term.\r\n */\r\nexport enum Kind {\r\n    /**\r\n     * Represents an expression standing for something which is either true or false (sentence).\r\n     */\r\n    Formula = 'Formula',\r\n    /**\r\n     * Represents an expression standing for a specific object (name).\r\n     */\r\n    Term = 'Term'\r\n}\r\n","import { Record } from 'immutable'\r\nimport { Category } from './category'\r\nimport { Kind } from './kind'\r\n\r\n/**\r\n * `Sym` (short for `Symbol`) represents the main syntactic entity from which expression tree\r\n * structure is built.\r\n *\r\n * Word `symbol` has been avoided because it's the name of the builtin type in ES6.\r\n */\r\nexport class Sym extends Record<{\r\n    /**\r\n     * Non-negative integer.\r\n     *\r\n     * Some algorithms need to temporarily generate new symbols which are not yet used. In such\r\n     * cases we use negative ids. For this reason it is very important to never introduce a symbol\r\n     * with negative id.\r\n     */\r\n    id: number\r\n    kind: Kind\r\n    argumentKind: Kind\r\n    arity: number\r\n    binds: boolean\r\n}>({\r\n    id: 0,\r\n    kind: Kind.Formula,\r\n    argumentKind: Kind.Formula,\r\n    arity: 0,\r\n    binds: false\r\n}, 'Sym') {\r\n    static fromCategory(c: Category, props: Partial<Sym> = {}): Sym {\r\n        return new Sym({ ...props, ...Sym.getKindsFromCategory(c) })\r\n    }\r\n\r\n    static ff(props: Partial<Sym> = {}) { return Sym.fromCategory(Category.FF, props)}\r\n\r\n    static ft(props: Partial<Sym> = {}) { return Sym.fromCategory(Category.FT, props)}\r\n\r\n    static tf(props: Partial<Sym> = {}) { return Sym.fromCategory(Category.TF, props)}\r\n\r\n    static tt(props: Partial<Sym> = {}) { return Sym.fromCategory(Category.TT, props)}\r\n\r\n    static getCategoriesWithKind(kind: Kind): readonly [Category, Category] {\r\n        switch (kind) {\r\n            case Kind.Formula:\r\n                return [Category.FF, Category.FT]\r\n            case Kind.Term:\r\n                return [Category.TF, Category.TT]\r\n        }\r\n    }\r\n\r\n    static getKindsFromCategory(category: Category) {\r\n        switch (category) {\r\n            case Category.FF:\r\n                return { kind: Kind.Formula, argumentKind: Kind.Formula }\r\n            case Category.FT:\r\n                return { kind: Kind.Formula, argumentKind: Kind.Term }\r\n            case Category.TF:\r\n                return { kind: Kind.Term, argumentKind: Kind.Formula }\r\n            case Category.TT:\r\n                return { kind: Kind.Term, argumentKind: Kind.Term }\r\n        }\r\n    }\r\n\r\n    getCategory() {\r\n        switch (this.kind) {\r\n            case Kind.Formula:\r\n                switch (this.argumentKind) {\r\n                    case Kind.Formula:\r\n                        return Category.FF\r\n                    case Kind.Term:\r\n                        return Category.FT\r\n                }\r\n                break\r\n            case Kind.Term:\r\n                switch (this.argumentKind) {\r\n                    case Kind.Formula:\r\n                        return Category.TF\r\n                    case Kind.Term:\r\n                        return Category.TT\r\n                }\r\n                break\r\n        }\r\n    }\r\n\r\n    toString() {\r\n        return `${this.id}-${this.getCategory()}${this.binds ? 'b' : ''}${this.arity}`\r\n    }\r\n\r\n    order({ id }: Sym) { return this.id - id }\r\n}\r\n","import { Deduction } from '../deduction-structure'\r\nimport { DeductionInterfaceError } from './error'\r\nimport { RulesInterface } from './rules-interface'\r\n\r\n/**\r\n * Interface which can be used to perform deduction by repeatedly applying available rules.\r\n *\r\n * Validity of deduction is ensured on each step. Validity of the resulting deduction is guaranteed\r\n * if initial deduction (if any) provided at the start os valid.\r\n */\r\nexport class DeductionInterface {\r\n    static start(deduction = new Deduction()) { return new DeductionInterface(deduction) }\r\n\r\n    constructor(readonly deduction: Deduction) {}\r\n\r\n    /** Select steps (formulas) to use as premises in the next rule. */\r\n    selectSteps(...ordinals: number[]) {\r\n        const indexes = this.createIndexes(...ordinals)\r\n        return RulesInterface(this.deduction, ...indexes)\r\n    }\r\n\r\n    private createIndexes(...ordinals: number[]) {\r\n        const stepOrdinalOutOfRange = ordinals.find(ordinal => !(\r\n            Number.isInteger(ordinal) && ordinal >= 1 && ordinal <= this.deduction.size\r\n        ))\r\n\r\n        if (stepOrdinalOutOfRange !== undefined) {\r\n            throw new StepOrdinalOutOfRangeError(stepOrdinalOutOfRange, this.deduction.size)\r\n        }\r\n\r\n        return ordinals.map(ordinal => ordinal - 1)\r\n    }\r\n}\r\n\r\nexport class StepOrdinalOutOfRangeError extends DeductionInterfaceError {\r\n    constructor(\r\n        readonly stepOrdinal: number,\r\n        readonly maxStepOrdinal: number\r\n    ) {\r\n        super(`step ordinal ${stepOrdinal} is out of range [1 - ${maxStepOrdinal}]`)\r\n    }\r\n}\r\n","import { BaseError } from '../error'\r\n\r\nexport abstract class DeductionInterfaceError extends BaseError {}\r\n","export { DeductionInterface } from './deduction-interface'\r\n","import { Deduction } from '../../deduction-structure'\r\nimport { RegularRuleApplicationSpec } from '../../deduction-structure/rule-application-spec'\r\nimport { DeductionInterface } from '../deduction-interface'\r\n\r\nexport class DeductionRuleInterface {\r\n    constructor(\r\n        private readonly deduction: Deduction,\r\n        private readonly firstStepIndex: number,\r\n        private readonly secondStepIndex: number\r\n    ) {}\r\n\r\n    apply() {\r\n        const ruleApplicationSpec = RegularRuleApplicationSpec.deduction(\r\n            this.deduction.getStep(this.firstStepIndex).formula,\r\n            this.firstStepIndex,\r\n            this.deduction.getStep(this.secondStepIndex).formula,\r\n            this.secondStepIndex\r\n        )\r\n        const newDeduction = this.deduction.applyRule(ruleApplicationSpec)\r\n        return new DeductionInterface(newDeduction)\r\n    }\r\n}\r\n","export { RulesInterface } from '../rules-interface/rules-interface'\r\n","import { Expression } from '../../abstract-structures/expression'\r\nimport { Deduction } from '../../deduction-structure'\r\nimport { RegularRuleApplicationSpec } from '../../deduction-structure/rule-application-spec'\r\nimport { DeductionInterface } from '../deduction-interface'\r\n\r\nexport class PremiseRuleInterface {\r\n    constructor(private deduction: Deduction) {}\r\n\r\n    apply(formula: Expression) {\r\n        const ruleApplicationSpec = RegularRuleApplicationSpec.premise(formula)\r\n        const newDeduction = this.deduction.applyRule(ruleApplicationSpec)\r\n        return new DeductionInterface(newDeduction)\r\n    }\r\n}\r\n","import { Sym } from '../../../abstract-structures/sym'\r\nimport { RegularRuleApplicationSpec } from '../../../deduction-structure/rule-application-spec'\r\nimport { DeductionInterface } from '../../deduction-interface'\r\nimport { GeneralizationRuleInterface } from './generalization-rule-interface'\r\n\r\nexport class ExistentialGeneralizationRuleInterface extends GeneralizationRuleInterface {\r\n    protected concreteApply(newTerm: Sym, oldTerm?: Sym) {\r\n        const ruleApplicationSpec = RegularRuleApplicationSpec.existentialGeneralization(\r\n            this.premise,\r\n            this.stepIndex,\r\n            newTerm,\r\n            oldTerm\r\n        )\r\n        const newDeduction = this.deduction.applyRule(ruleApplicationSpec)\r\n        return new DeductionInterface(newDeduction)\r\n    }\r\n}\r\n","import { Sym } from '../../../abstract-structures/sym'\r\nimport { RegularRuleApplicationSpec } from '../../../deduction-structure/rule-application-spec'\r\nimport {\r\n    CyclicDependenciesError as TermDependencyGraphCyclicDependenciesError,\r\n    TermAlreadyUsedError as TermDependencyGraphTermAlreadyUsedError\r\n} from '../../../deduction-structure/term-dependency-graph'\r\nimport { DeductionInterface } from '../../deduction-interface'\r\nimport { InstantiationRuleInterface } from './instantiation-rule-interface'\r\nimport { TermAlreadyUsedError, TermsCyclicDependenciesError } from './quantification-rule-interface'\r\n\r\nexport class ExistentialInstantiationRuleInterface extends InstantiationRuleInterface {\r\n    protected concreteApply(newTerm?: Sym): DeductionInterface {\r\n        const ruleApplicationSpec = RegularRuleApplicationSpec.existentialInstantiation(\r\n            this.premise,\r\n            this.stepIndex,\r\n            newTerm\r\n        )\r\n\r\n        try {\r\n            const newDeduction = this.deduction.applyRule(ruleApplicationSpec)\r\n            return new DeductionInterface(newDeduction)\r\n        } catch (e) {\r\n            if (e instanceof TermDependencyGraphTermAlreadyUsedError) {\r\n                throw new TermAlreadyUsedError(e.term)\r\n            } else if (e instanceof TermDependencyGraphCyclicDependenciesError) {\r\n                throw new TermsCyclicDependenciesError(e.dependentTerm, e.dependencyTerm)\r\n            }\r\n            throw e\r\n        }\r\n    }\r\n}\r\n","import { is } from 'immutable'\r\nimport { Expression, NoChildAtIndexError } from '../../../abstract-structures/expression'\r\nimport { Sym } from '../../../abstract-structures/sym'\r\nimport { DeductionInterface } from '../../deduction-interface'\r\nimport { DeductionInterfaceError } from '../../error'\r\nimport {\r\n    InvalidSubstitutionResultError,\r\n    QuantificationRuleInterface\r\n} from './quantification-rule-interface'\r\n\r\nexport abstract class GeneralizationRuleInterface extends QuantificationRuleInterface {\r\n    /**\r\n     * @param newTerm - Generalized term which will be the substituent of the substitution.\r\n     * @param oldTerm - Instance term which if provided will be the substituendum of the\r\n     * substitution. If it's not provided generalization will be is vacuous.\r\n     */\r\n    apply(newTerm: Sym, oldTerm?: Sym) {\r\n        const premise = this.premise\r\n\r\n        const substitutionRequired = !is(newTerm, oldTerm)\r\n        if (substitutionRequired) {\r\n            if (premise.getFreeSyms().contains(newTerm)) {\r\n                throw new GeneralizedTermIllegallyBindsError()\r\n            }\r\n\r\n            if (\r\n                oldTerm !== undefined &&\r\n                premise.findBoundSymsAtFreeOccurrencesOfSym(oldTerm).contains(newTerm)\r\n            ) {\r\n                throw new GeneralizedTermBecomesIllegallyBoundError()\r\n            }\r\n        }\r\n\r\n        return this.concreteApply(newTerm, oldTerm)\r\n    }\r\n\r\n    protected abstract concreteApply(newSym: Sym, oldSym?: Sym): DeductionInterface\r\n\r\n    /**\r\n     * Under assumption that `formula` is a result of an application of this rule determine which\r\n     * term was introduced in substitution.\r\n     */\r\n    determineSubstitutionInPotentialResult(formula: Expression): Substitution {\r\n        const newTerm = formula.boundSym\r\n        if (newTerm === undefined) throw new InvalidSubstitutionResultError()\r\n\r\n        try {\r\n            const firstBoundOccurrencePosition = formula.findBoundOccurrences().first(undefined)\r\n            if (firstBoundOccurrencePosition === undefined) return { newTerm }\r\n            const oldTerm = this.premise.getSubexpression(firstBoundOccurrencePosition.shift()).sym\r\n            return { oldTerm, newTerm }\r\n        } catch (e) {\r\n            if (e instanceof NoChildAtIndexError) {\r\n                throw new InvalidSubstitutionResultError()\r\n            }\r\n            throw e\r\n        }\r\n    }\r\n}\r\n\r\ninterface Substitution {\r\n    oldTerm?: Sym\r\n    newTerm: Sym\r\n}\r\n\r\nexport class GeneralizedTermIllegallyBindsError extends DeductionInterfaceError {}\r\n\r\nexport class GeneralizedTermBecomesIllegallyBoundError extends DeductionInterfaceError {}\r\n","export { UniversalGeneralizationRuleInterface } from './universal-generalization-rule-interface'\r\nexport {\r\n    ExistentialGeneralizationRuleInterface\r\n} from './existential-generalization-rule-interface'\r\nexport { UniversalInstantiationRuleInterface } from './universal-instantiation-rule-interface'\r\nexport { ExistentialInstantiationRuleInterface } from './existential-instantiation-rule-interface'\r\n","import { Expression, NoChildAtIndexError } from '../../../abstract-structures/expression'\r\nimport { Sym } from '../../../abstract-structures/sym'\r\nimport { DeductionInterface } from '../../deduction-interface'\r\nimport { DeductionInterfaceError } from '../../error'\r\nimport {\r\n    InvalidSubstitutionResultError,\r\n    QuantificationRuleInterface\r\n} from './quantification-rule-interface'\r\n\r\nexport abstract class InstantiationRuleInterface extends QuantificationRuleInterface {\r\n    /**\r\n     * @param newTerm - Instance term which if provided will be the substituendum of the\r\n     * substitution. If instantiation is vacuous newTerm doesn't need to be provided.\r\n     */\r\n    apply(newTerm?: Sym) {\r\n        const premise = this.premise\r\n\r\n        if (newTerm === undefined) {\r\n            if (!premise.findBoundOccurrences().isEmpty()) {\r\n                throw new TermNotProvidedForNonVacuousQuantificationError()\r\n            }\r\n        } else {\r\n            const oldTerm = premise.boundSym!\r\n            const child = premise.children.first<Expression>()\r\n            if (child.findBoundSymsAtFreeOccurrencesOfSym(oldTerm).contains(newTerm)) {\r\n                throw new InstanceTermBecomesIllegallyBoundError()\r\n            }\r\n        }\r\n\r\n        return this.concreteApply(newTerm)\r\n    }\r\n\r\n    protected abstract concreteApply(newSym?: Sym): DeductionInterface\r\n\r\n    /**\r\n     * Under assumption that `formula` is a result of an application of this rule determine which\r\n     * term was introduced in substitution. If instantiation was vacuous return `undefined`.\r\n     */\r\n    determineNewTermInPotentialResult(formula: Expression) {\r\n        const firstOccurrence = this.premise.findBoundOccurrences().first<undefined>()\r\n        if (firstOccurrence === undefined) return undefined\r\n\r\n        try {\r\n            return formula.getSubexpression(firstOccurrence.shift()).sym\r\n        } catch (e) {\r\n            if (e instanceof NoChildAtIndexError) {\r\n                throw new InvalidSubstitutionResultError()\r\n            }\r\n            throw e\r\n        }\r\n    }\r\n}\r\n\r\nexport class TermNotProvidedForNonVacuousQuantificationError extends DeductionInterfaceError {}\r\n\r\nexport class InstanceTermBecomesIllegallyBoundError extends DeductionInterfaceError {}\r\n","import { Sym } from '../../../abstract-structures/sym'\r\nimport { Deduction } from '../../../deduction-structure'\r\nimport { DeductionInterfaceError } from '../../error'\r\n\r\nexport abstract class QuantificationRuleInterface {\r\n    constructor(\r\n        protected readonly deduction: Deduction,\r\n        protected readonly stepIndex: number\r\n    ) {}\r\n\r\n    protected get premise() { return this.deduction.getStep(this.stepIndex).formula }\r\n}\r\n\r\nexport class InvalidSubstitutionResultError extends DeductionInterfaceError {}\r\n\r\nexport class TermAlreadyUsedError extends DeductionInterfaceError {\r\n    constructor(readonly term: Sym) {\r\n        super(`term ${term} is already used`)\r\n    }\r\n}\r\n\r\nexport class TermsCyclicDependenciesError extends DeductionInterfaceError {\r\n    constructor(\r\n        readonly dependentTerm: Sym,\r\n        readonly dependencyTerm: Sym\r\n    ) {\r\n        super(`term ${dependentTerm} forms a cycle by depending on ${dependencyTerm}`)\r\n    }\r\n}\r\n","import { Sym } from '../../../abstract-structures/sym'\r\nimport { RegularRuleApplicationSpec } from '../../../deduction-structure/rule-application-spec'\r\nimport {\r\n    CyclicDependenciesError as TermDependencyGraphCyclicDependenciesError,\r\n    TermAlreadyUsedError as TermDependencyGraphTermAlreadyUsedError\r\n} from '../../../deduction-structure/term-dependency-graph'\r\nimport { DeductionInterface } from '../../deduction-interface'\r\nimport { GeneralizationRuleInterface } from './generalization-rule-interface'\r\nimport { TermAlreadyUsedError, TermsCyclicDependenciesError } from './quantification-rule-interface'\r\n\r\nexport class UniversalGeneralizationRuleInterface extends GeneralizationRuleInterface {\r\n    protected concreteApply(newTerm: Sym, oldTerm?: Sym) {\r\n        const ruleApplicationSpec = RegularRuleApplicationSpec.universalGeneralization(\r\n            this.premise,\r\n            this.stepIndex,\r\n            newTerm,\r\n            oldTerm\r\n        )\r\n\r\n        try {\r\n            const newDeduction = this.deduction.applyRule(ruleApplicationSpec)\r\n            return new DeductionInterface(newDeduction)\r\n        } catch (e) {\r\n            if (e instanceof TermDependencyGraphTermAlreadyUsedError) {\r\n                throw new TermAlreadyUsedError(e.term)\r\n            } else if (e instanceof TermDependencyGraphCyclicDependenciesError) {\r\n                throw new TermsCyclicDependenciesError(e.dependentTerm, e.dependencyTerm)\r\n            }\r\n            throw e\r\n        }\r\n    }\r\n}\r\n","import { Sym } from '../../../abstract-structures/sym'\r\nimport { RegularRuleApplicationSpec } from '../../../deduction-structure/rule-application-spec'\r\nimport { DeductionInterface } from '../../deduction-interface'\r\nimport { InstantiationRuleInterface } from './instantiation-rule-interface'\r\n\r\nexport class UniversalInstantiationRuleInterface extends InstantiationRuleInterface {\r\n    protected concreteApply(newTerm?: Sym): DeductionInterface {\r\n        const ruleApplicationSpec = RegularRuleApplicationSpec.universalInstantiation(\r\n            this.premise,\r\n            this.stepIndex,\r\n            newTerm\r\n        )\r\n        const newDeduction = this.deduction.applyRule(ruleApplicationSpec)\r\n        return new DeductionInterface(newDeduction)\r\n    }\r\n}\r\n","import { Deduction } from '../../deduction-structure'\r\nimport { Rule } from '../../deduction-structure/rule'\r\nimport { existentialQuantifier, universalQuantifier } from '../../primitive-syms'\r\nimport { DeductionRuleInterface } from './deduction-rule-interface'\r\nimport { PremiseRuleInterface } from './premise-rule-interface'\r\nimport {\r\n    ExistentialGeneralizationRuleInterface,\r\n    ExistentialInstantiationRuleInterface,\r\n    UniversalGeneralizationRuleInterface,\r\n    UniversalInstantiationRuleInterface\r\n} from './quantification'\r\nimport { TautologicalImplicationRuleInterface } from './tautological-implication-rule-interface'\r\nimport { TheoremRuleInterface } from './theorem-rule-interface'\r\n\r\n/**\r\n * Accept deduction and selected steps (step indexes), determine possible rules which could be\r\n * applied and return interfaces for their application.\r\n */\r\nexport const RulesInterface = (deduction: Deduction, ...steps: number[]): RulesInterface => {\r\n    const result: RulesInterface = {}\r\n\r\n    result[Rule.TautologicalImplication] = new TautologicalImplicationRuleInterface(\r\n        deduction,\r\n        steps\r\n    )\r\n\r\n    if (steps.length === 0) {\r\n        result[Rule.Premise] = new PremiseRuleInterface(deduction)\r\n        result[Rule.Theorem] = new TheoremRuleInterface(deduction)\r\n    } else if (steps.length == 1) {\r\n        const [step] = steps\r\n\r\n        const premise = deduction.getStep(step).formula\r\n\r\n        if (premise.sym.equals(universalQuantifier)) {\r\n            result[Rule.UniversalInstantiation] = new UniversalInstantiationRuleInterface(\r\n                deduction,\r\n                step\r\n            )\r\n        } else if (premise.sym.equals(existentialQuantifier)) {\r\n            result[Rule.ExistentialInstantiation] = new ExistentialInstantiationRuleInterface(\r\n                deduction,\r\n                step\r\n            )\r\n\r\n        }\r\n\r\n        result[Rule.UniversalGeneralization] = new UniversalGeneralizationRuleInterface(\r\n            deduction,\r\n            step\r\n        )\r\n        result[Rule.ExistentialGeneralization] = new ExistentialGeneralizationRuleInterface(\r\n            deduction,\r\n            step\r\n        )\r\n    } else if (steps.length === 2) {\r\n        const [firstStepIndex, secondStepIndex] = steps\r\n        const [firstStep, secondStep] = steps.map(i => deduction.getStep(i))\r\n\r\n        const firstStepIsPremise = firstStep.ruleApplicationSummary.rule === Rule.Premise\r\n        const firstIsAssumptionForSecond = secondStep.assumptions\r\n            .contains(firstStepIndex)\r\n\r\n        if (firstStepIsPremise && firstIsAssumptionForSecond) {\r\n            result[Rule.Deduction] = new DeductionRuleInterface(\r\n                deduction,\r\n                firstStepIndex,\r\n                secondStepIndex\r\n            )\r\n        }\r\n    }\r\n\r\n    return result\r\n}\r\n\r\nexport interface RulesInterface {\r\n    [Rule.Premise]?: PremiseRuleInterface\r\n    [Rule.Deduction]?: DeductionRuleInterface\r\n    [Rule.TautologicalImplication]?: TautologicalImplicationRuleInterface\r\n    [Rule.UniversalInstantiation]?: UniversalInstantiationRuleInterface\r\n    [Rule.UniversalGeneralization]?: UniversalGeneralizationRuleInterface\r\n    [Rule.ExistentialInstantiation]?: ExistentialInstantiationRuleInterface\r\n    [Rule.ExistentialGeneralization]?: ExistentialGeneralizationRuleInterface\r\n    [Rule.Theorem]?: TheoremRuleInterface\r\n}\r\n","import { OrderedSet } from 'immutable'\r\nimport { Expression } from '../../abstract-structures/expression'\r\nimport { Deduction } from '../../deduction-structure'\r\nimport { RegularRuleApplicationSpec } from '../../deduction-structure/rule-application-spec'\r\nimport { isLogicalConsequence } from '../../propositional-logic/propositional-logic'\r\nimport { DeductionInterface } from '../deduction-interface'\r\nimport { DeductionInterfaceError } from '../error'\r\n\r\nexport class TautologicalImplicationRuleInterface {\r\n    constructor(\r\n        private readonly deduction: Deduction,\r\n        private readonly stepIndexes: number[] = []\r\n    ) {}\r\n\r\n    apply(formula: Expression) {\r\n        const assumptions = this.stepIndexes.map(i => this.deduction.getStep(i).formula)\r\n\r\n        if (!isLogicalConsequence(assumptions, formula)) {\r\n            throw new InvalidTautologicalImplicationError(assumptions, formula)\r\n        }\r\n\r\n        const ruleApplicationSpec = RegularRuleApplicationSpec.tautologicalImplication(\r\n            OrderedSet(this.stepIndexes),\r\n            formula\r\n        )\r\n        const newDeduction = this.deduction.applyRule(ruleApplicationSpec)\r\n        return new DeductionInterface(newDeduction)\r\n    }\r\n}\r\n\r\nexport class InvalidTautologicalImplicationError extends DeductionInterfaceError {\r\n    constructor(\r\n        readonly assumptions: Expression[],\r\n        readonly consequence: Expression\r\n    ) {\r\n        super(`assumption(s) ${assumptions.join(', ')} do(es)n't entail ${consequence}`)\r\n    }\r\n}\r\n","import { Deduction } from '../../deduction-structure'\r\nimport { DeductionInterface } from '../deduction-interface'\r\n\r\nexport class TheoremRuleInterface {\r\n    constructor(private readonly deduction: Deduction) {}\r\n\r\n    apply() { return new DeductionInterface(this.deduction) }\r\n}\r\n","import { List, OrderedSet, Record } from 'immutable'\r\nimport { Rule } from './rule'\r\nimport {\r\n    RegularRuleApplicationSpec,\r\n    RuleApplicationSpec,\r\n    TheoremRuleApplicationSpec\r\n} from './rule-application-spec'\r\nimport {\r\n    RegularRuleApplicationSummary,\r\n    TheoremRuleApplicationSummary\r\n} from './rule-application-summary'\r\nimport { Step } from './step'\r\nimport { TermDependencyGraph } from './term-dependency-graph'\r\nimport { TermDependencies } from './term-dependency-graph/term-dependencies'\r\n\r\n/**\r\n * Structure containing all relevant information about some deduction (proof) carried out as a\r\n * sequence of steps.\r\n */\r\nexport class Deduction extends Record<{\r\n    steps: List<Step>\r\n    termDependencyGraph: TermDependencyGraph\r\n}>({\r\n    steps: List(),\r\n    termDependencyGraph: new TermDependencyGraph()\r\n}, 'Deduction') {\r\n    get size() { return this.steps.size }\r\n\r\n    /**\r\n     * Derive new deduction by applying rule.\r\n     *\r\n     * @param ruleApplicationSpec - Specification of the rule to apply.\r\n     */\r\n    applyRule(ruleApplicationSpec: RuleApplicationSpec) {\r\n        return ruleApplicationSpec.rule === Rule.Theorem\r\n            ? this.applyTheoremRule(ruleApplicationSpec)\r\n            : this.applyRegularRule(ruleApplicationSpec)\r\n    }\r\n\r\n    private applyTheoremRule(\r\n        { theorem: formula, theoremId }: TheoremRuleApplicationSpec\r\n    ) {\r\n        const ruleApplicationSummary = new TheoremRuleApplicationSummary({\r\n            rule: Rule.Theorem,\r\n            theoremId\r\n        })\r\n        const step = new Step({ formula, ruleApplicationSummary })\r\n        return this.addStep(step)\r\n    }\r\n\r\n    private applyRegularRule(\r\n        {\r\n            rule,\r\n            premises,\r\n            conclusion,\r\n            termDependencies,\r\n            assumptionToRemove\r\n        }: RegularRuleApplicationSpec\r\n    ) {\r\n        const assumptions = this.calculateAssumptions(\r\n            premises,\r\n            assumptionToRemove\r\n        )\r\n\r\n        const ruleApplicationSummary = new RegularRuleApplicationSummary({\r\n            rule,\r\n            premises,\r\n            termDependencies\r\n        })\r\n\r\n        const step = new Step({\r\n            assumptions,\r\n            formula: conclusion,\r\n            ruleApplicationSummary\r\n        })\r\n\r\n        const graph = termDependencies === undefined\r\n            ? this.termDependencyGraph\r\n            : this.updateGraph(termDependencies)\r\n\r\n        return this.addStep(step).setGraph(graph)\r\n    }\r\n\r\n    /**\r\n     * Get step by its ordinal number.\r\n     *\r\n     * From regular user's perspective steps are referenced by positive integers starting from 1.\r\n     * Internally we use list indexes which start from 0.\r\n     */\r\n    getStepByOrdinal(ordinal: number) {\r\n        return this.getStep(ordinal - 1)\r\n    }\r\n\r\n    getStep(stepIndex: number) {\r\n        const step = this.steps.get(stepIndex)\r\n        if (step === undefined) throw new Error(`no step at index ${stepIndex}`)\r\n        return step\r\n    }\r\n\r\n    getLastStep() {\r\n        const step = this.steps.last(undefined)\r\n        if (step === undefined) throw new Error('no last step')\r\n        return step\r\n    }\r\n\r\n    /**\r\n     * Calculate which assumptions must be added according to the specified rule premises.\r\n     *\r\n     * Assumptions are inherited from all premises. In addition to that if premise was introduced\r\n     * by `Premise` or `Theorem` rule, its index is also added as an assumption.\r\n     */\r\n    private calculateAssumptions(\r\n        premises: OrderedSet<number>,\r\n        toRemove?: number\r\n    ) {\r\n        let assumptions = premises\r\n            .toIndexedSeq()\r\n            .map(premise => this.getStep(premise))\r\n            .flatMap(\r\n                ({ assumptions, ruleApplicationSummary: { rule } }: Step, i: number) => {\r\n                    if (rule === Rule.Premise || rule === Rule.Theorem) {\r\n                        assumptions = assumptions.add(i)\r\n                    }\r\n                    return assumptions\r\n                })\r\n            .toSet()\r\n\r\n        if (toRemove !== undefined) assumptions = assumptions.remove(toRemove)\r\n\r\n        return assumptions\r\n    }\r\n\r\n    /** Calculate new graph according to changes required by the rule. */\r\n    private updateGraph({ dependent, dependencies }: TermDependencies) {\r\n        return this.termDependencyGraph.addDependencies(dependent, ...dependencies.toArray())\r\n    }\r\n\r\n    addStep(step: Step) {\r\n        return this.update('steps', steps => steps.push(step))\r\n    }\r\n\r\n    private setGraph(graph: TermDependencyGraph) {\r\n        return this.set('termDependencyGraph', graph)\r\n    }\r\n}\r\n","export { Deduction } from './deduction'\r\n","import { RegularRuleApplicationSpec } from './regular-rule-application-spec'\r\nimport { TheoremRuleApplicationSpec } from './theorem-rule-application-spec'\r\n\r\nexport * from './regular-rule-application-spec'\r\nexport * from './theorem-rule-application-spec'\r\n\r\nexport type RuleApplicationSpec = RegularRuleApplicationSpec | TheoremRuleApplicationSpec\r\n","import { List, OrderedSet, Record } from 'immutable'\r\nimport { Expression } from '../../abstract-structures/expression'\r\nimport { Sym } from '../../abstract-structures/sym'\r\nimport { existentialQuantifier, implication, universalQuantifier } from '../../primitive-syms'\r\nimport { Rule } from '../rule'\r\nimport { TermDependencies } from '../term-dependency-graph/term-dependencies'\r\n\r\n/**\r\n * Contains all information necessary to apply a regular rule (not theorem rule) against a\r\n * deduction.\r\n *\r\n * Notes:\r\n * - Deduction to which the rule will be applied we will call 'target deduction'.\r\n * - In the following lines we sometimes refer to formulas by numbers. Number in such contexts is\r\n *   the index of the target deduction's step which introduced the formula in question (as a result\r\n *   of the premise rule or theorem rule).\r\n *\r\n * All rules (except theorem) are reduced to this object. It contains all data necessary to\r\n * construct the next step of the target deduction. This object can be considered as some sort of a\r\n * common denominator of all regular rules.\r\n *\r\n * Note: static factory methods don't validate data!\r\n */\r\nexport class RegularRuleApplicationSpec extends Record<{\r\n    rule: Exclude<Rule, Rule.Theorem>\r\n\r\n    /** Formulas which will serve as the premises of this rule. */\r\n    premises: OrderedSet<number>\r\n\r\n    /** Resulting formula which will be introduced in the next target deduction's step. */\r\n    conclusion: Expression\r\n\r\n    /** Assumptions to remove from the inherited set of assumptions. **/\r\n    assumptionToRemove?: number\r\n\r\n    /** Term dependencies with which to extend target deduction's term dependency graph. **/\r\n    termDependencies?: TermDependencies\r\n}>({\r\n    rule: Rule.Premise,\r\n    premises: OrderedSet(),\r\n    conclusion: new Expression(),\r\n    termDependencies: undefined,\r\n    assumptionToRemove: undefined\r\n}, 'RegularRuleApplicationSpec') {\r\n    static premise(premise: Expression) {\r\n        return new RegularRuleApplicationSpec({\r\n            rule: Rule.Premise,\r\n            conclusion: premise\r\n        })\r\n    }\r\n\r\n    static deduction(\r\n        antecedent: Expression,\r\n        antecedentIndex: number,\r\n        consequent: Expression,\r\n        consequentIndex: number\r\n    ) {\r\n        return new RegularRuleApplicationSpec({\r\n            rule: Rule.Deduction,\r\n            premises: OrderedSet.of(antecedentIndex, consequentIndex),\r\n            conclusion: new Expression({\r\n                sym: implication,\r\n                children: List.of(antecedent, consequent)\r\n            }),\r\n            assumptionToRemove: antecedentIndex\r\n        })\r\n    }\r\n\r\n    static tautologicalImplication(premises: OrderedSet<number>, conclusion: Expression) {\r\n        return new RegularRuleApplicationSpec({\r\n            rule: Rule.TautologicalImplication,\r\n            premises,\r\n            conclusion\r\n        })\r\n    }\r\n\r\n    static universalInstantiation(\r\n        { boundSym, children }: Expression,\r\n        premiseIndex: number,\r\n        newTerm?: Sym\r\n    ) {\r\n        const child = children.get(0)!\r\n        const conclusion = newTerm !== undefined\r\n            ? child.replaceFreeOccurrences(boundSym!, newTerm)\r\n            : child\r\n\r\n        return new RegularRuleApplicationSpec({\r\n            rule: Rule.UniversalInstantiation,\r\n            premises: OrderedSet.of(premiseIndex),\r\n            conclusion\r\n        })\r\n    }\r\n\r\n    static universalGeneralization(\r\n        premise: Expression,\r\n        premiseIndex: number,\r\n        newTerm: Sym,\r\n        oldTerm?: Sym\r\n    ) {\r\n        const child = oldTerm !== undefined\r\n            ? premise.replaceFreeOccurrences(oldTerm, newTerm)\r\n            : premise\r\n\r\n        return new RegularRuleApplicationSpec({\r\n            rule: Rule.UniversalGeneralization,\r\n            premises: OrderedSet.of(premiseIndex),\r\n            conclusion: new Expression({\r\n                sym: universalQuantifier,\r\n                boundSym: newTerm,\r\n                children: List.of(child)\r\n            }),\r\n            termDependencies: oldTerm !== undefined\r\n                ? premise\r\n                    .getFreeTerms()\r\n                    .remove(oldTerm)\r\n                    .reduce(\r\n                        (acc, dependencyTerm) => acc.addDependency(dependencyTerm),\r\n                        new TermDependencies({ dependent: oldTerm })\r\n                    )\r\n                : undefined\r\n        })\r\n    }\r\n\r\n    static existentialInstantiation(\r\n        { boundSym, children }: Expression,\r\n        premiseIndex: number,\r\n        newTerm?: Sym\r\n    ) {\r\n        const child = children.get(0)!\r\n        const conclusion = newTerm !== undefined\r\n            ? child.replaceFreeOccurrences(boundSym!, newTerm)\r\n            : child\r\n\r\n\r\n        return new RegularRuleApplicationSpec({\r\n            rule: Rule.ExistentialInstantiation,\r\n            premises: OrderedSet.of(premiseIndex),\r\n            conclusion,\r\n            termDependencies: newTerm !== undefined\r\n                ? conclusion\r\n                    .getFreeTerms()\r\n                    .remove(newTerm)\r\n                    .reduce(\r\n                        (acc, dependencyTerm) => acc.addDependency(dependencyTerm),\r\n                        new TermDependencies({ dependent: newTerm })\r\n                    )\r\n                : undefined\r\n        })\r\n    }\r\n\r\n    static existentialGeneralization(\r\n        premise: Expression,\r\n        premiseIndex: number,\r\n        newTerm: Sym,\r\n        oldTerm?: Sym\r\n    ) {\r\n        const child = oldTerm !== undefined\r\n            ? premise.replaceFreeOccurrences(oldTerm, newTerm)\r\n            : premise\r\n\r\n        return new RegularRuleApplicationSpec({\r\n            rule: Rule.ExistentialGeneralization,\r\n            premises: OrderedSet.of(premiseIndex),\r\n            conclusion: new Expression({\r\n                sym: existentialQuantifier,\r\n                boundSym: newTerm,\r\n                children: List.of(child)\r\n            })\r\n        })\r\n    }\r\n}\r\n","import { Record } from 'immutable'\r\nimport { Expression } from '../../abstract-structures/expression'\r\nimport { Rule } from '../rule'\r\n\r\n/** Contains all information necessary to apply the theorem rule against a deduction. */\r\nexport class TheoremRuleApplicationSpec extends Record<{\r\n    rule: Rule.Theorem\r\n\r\n    /** Identifier of the theorem in a project. */\r\n    theoremId: string\r\n    theorem: Expression\r\n}>({\r\n    rule: Rule.Theorem,\r\n    theoremId: '',\r\n    theorem: new Expression()\r\n}, 'TheoremRuleApplicationSpec') {}\r\n","import { RegularRuleApplicationSummary } from './regular-rule-application-summary'\r\nimport { TheoremRuleApplicationSummary } from './theorem-rule-application-summary'\r\n\r\nexport * from './regular-rule-application-summary'\r\nexport * from './theorem-rule-application-summary'\r\n\r\nexport type RuleApplicationSummary = RegularRuleApplicationSummary | TheoremRuleApplicationSummary\r\n","import { OrderedSet, Record } from 'immutable'\r\nimport { Rule } from '../rule'\r\nimport { TermDependencies } from '../term-dependency-graph/term-dependencies'\r\n\r\nexport class RegularRuleApplicationSummary extends Record<{\r\n    rule: Exclude<Rule, Rule.Theorem>\r\n    premises: OrderedSet<number>\r\n\r\n    /** Term dependencies introduced in this rule. */\r\n    termDependencies?: TermDependencies\r\n}>({\r\n    rule: Rule.Premise,\r\n    premises: OrderedSet(),\r\n    termDependencies: undefined\r\n}, 'RegularRuleApplicationSummary') {}\r\n","import { Record } from 'immutable'\r\nimport { Rule } from '../rule'\r\n\r\nexport class TheoremRuleApplicationSummary extends Record<{\r\n    rule: Rule.Theorem\r\n    theoremId: string\r\n}>({\r\n    rule: Rule.Theorem,\r\n    theoremId: ''\r\n}, 'TheoremRuleApplicationSummary') {}\r\n","/**\r\n * Fixed set of rule names/identifiers available in deduction.\r\n */\r\nexport enum Rule {\r\n    Premise = 'Premise',\r\n    Deduction = 'Deduction',\r\n    TautologicalImplication = 'TautologicalImplication',\r\n    UniversalInstantiation = 'UniversalInstantiation',\r\n    UniversalGeneralization = 'UniversalGeneralization',\r\n    ExistentialInstantiation = 'ExistentialInstantiation',\r\n    ExistentialGeneralization = 'ExistentialGeneralization',\r\n    Theorem = 'Theorem',\r\n}\r\n\r\nexport enum RuleAbbreviation {\r\n    P = 'P',\r\n    D = 'D',\r\n    TI = 'TI',\r\n    UI = 'UI',\r\n    UG = 'UG',\r\n    EI = 'EI',\r\n    EG = 'EG',\r\n    T = 'T'\r\n}\r\n\r\nexport const getAbbreviation = (rule: Rule) => ruleToAbbreviation[rule]\r\nexport const getRule = (abbreviation: RuleAbbreviation) => abbreviationToRule[abbreviation]\r\n\r\nconst ruleToAbbreviation: Record<Rule, RuleAbbreviation> = {\r\n    [Rule.Premise]: RuleAbbreviation.P,\r\n    [Rule.Deduction]: RuleAbbreviation.D,\r\n    [Rule.TautologicalImplication]: RuleAbbreviation.TI,\r\n    [Rule.UniversalInstantiation]: RuleAbbreviation.UI,\r\n    [Rule.UniversalGeneralization]: RuleAbbreviation.UG,\r\n    [Rule.ExistentialInstantiation]: RuleAbbreviation.EI,\r\n    [Rule.ExistentialGeneralization]: RuleAbbreviation.EG,\r\n    [Rule.Theorem]: RuleAbbreviation.T\r\n}\r\n\r\nconst abbreviationToRule: Record<RuleAbbreviation, Rule> = {\r\n    [RuleAbbreviation.P]: Rule.Premise,\r\n    [RuleAbbreviation.D]: Rule.Deduction,\r\n    [RuleAbbreviation.TI]: Rule.TautologicalImplication,\r\n    [RuleAbbreviation.UI]: Rule.UniversalInstantiation,\r\n    [RuleAbbreviation.UG]: Rule.UniversalGeneralization,\r\n    [RuleAbbreviation.EI]: Rule.ExistentialInstantiation,\r\n    [RuleAbbreviation.EG]: Rule.ExistentialGeneralization,\r\n    [RuleAbbreviation.T]: Rule.Theorem\r\n}\r\n","import { Record, Set } from 'immutable'\r\nimport { Expression } from '../abstract-structures/expression'\r\nimport { RegularRuleApplicationSummary, RuleApplicationSummary } from './rule-application-summary'\r\n\r\nexport class Step extends Record<{\r\n    /** Indexes of assumptions previously introduced and upon which this step depends. */\r\n    assumptions: Set<number>\r\n\r\n    /** Formula introduced in this step. */\r\n    formula: Expression\r\n\r\n    /**\r\n     * Justification for the introduction of `formula` in this step:\r\n     * - Which rule was used?\r\n     * - How was the rule applied?\r\n     * - What change must be made to the term dependency graph?\r\n     */\r\n    ruleApplicationSummary: RuleApplicationSummary\r\n}>({\r\n    assumptions: Set(),\r\n    formula: new Expression(),\r\n    ruleApplicationSummary: new RegularRuleApplicationSummary()\r\n}, 'Step') {}\r\n","export * from './term-dependency-graph'\r\n","import { Record, Set } from 'immutable'\r\nimport { Sym } from '../../abstract-structures/sym'\r\n\r\n/** Dependencies for a single term. */\r\nexport class TermDependencies extends Record<{\r\n    dependent: Sym\r\n    dependencies: Set<Sym>\r\n}>({\r\n    dependent: new Sym(),\r\n    dependencies: Set()\r\n}) {\r\n    addDependency(dependency: Sym) {\r\n        return this.update('dependencies', dependencies => dependencies.add(dependency))\r\n    }\r\n}\r\n","import { Map, Record, Set } from 'immutable'\r\nimport { Sym } from '../../abstract-structures/sym'\r\nimport { BaseError } from '../../error'\r\n\r\n/**\r\n * Graph of dependencies between free terms of a deduction.\r\n *\r\n * This graph is maintained as a part of deduction. It's updated on each application of UG and\r\n * EI rule.\r\n */\r\nexport class TermDependencyGraph extends Record<{\r\n    /** Direct dependencies. */\r\n    dependencies: Map<Sym, Set<Sym>>\r\n}>({ dependencies: Map() }, 'TermDependencyGraph') {\r\n    /**\r\n     * Add direct dependency and normalize graph (remove redundant direct dependencies which now\r\n     * became transitive).\r\n     */\r\n    addDependencies(dependent: Sym, ...dependencies: Sym[]) {\r\n        const dependenciesSet = Set(dependencies)\r\n\r\n        if (this.dependencies.has(dependent)) {\r\n            throw new TermAlreadyUsedError(dependent)\r\n        }\r\n\r\n        const cycleInducingDependency = dependenciesSet.find(\r\n            dependency => this.hasDependency(dependency, dependent)\r\n        )\r\n        if (cycleInducingDependency !== undefined) {\r\n            throw new CyclicDependenciesError(dependent, cycleInducingDependency)\r\n        }\r\n\r\n        return dependenciesSet.reduce<TermDependencyGraph>(\r\n            (acc, dependency) => acc.normalize(dependent, dependency).update(\r\n                'dependencies',\r\n                map => map.update(dependent, Set(), values => values.add(dependency))\r\n            ),\r\n            this.update('dependencies', map => map.set(dependent, Set()))\r\n        )\r\n    }\r\n\r\n    getDirectDependents(sym: Sym) {\r\n        return this.dependencies\r\n            .entrySeq()\r\n            .filter(([, dependencies]) => dependencies.contains(sym))\r\n            .map(([dependent]) => dependent)\r\n            .toSet()\r\n    }\r\n\r\n    getDependents(sym: Sym) { return this._getDependents(sym) }\r\n\r\n    private _getDependents(sym: Sym, traversed = Set<Sym>()): Set<Sym> {\r\n        if (traversed.contains(sym)) throw new Error('Infinite recursion error')\r\n        traversed = traversed.add(sym)\r\n\r\n        const directDependents = this.getDirectDependents(sym)\r\n\r\n        return directDependents.reduce(\r\n            (acc, dependent) => acc.union(this._getDependents(dependent, traversed)),\r\n            directDependents\r\n        )\r\n    }\r\n\r\n    getDependencies(sym: Sym) { return this._getDependencies(sym) }\r\n\r\n    private _getDependencies(sym: Sym, traversed = Set<Sym>()): Set<Sym> {\r\n        if (traversed.contains(sym)) throw new Error('Infinite recursion error')\r\n        traversed = traversed.add(sym)\r\n\r\n        const directDependencies = this.dependencies.get(sym, Set<Sym>())\r\n\r\n        return directDependencies.reduce(\r\n            (acc, dependent) => acc.union(this._getDependencies(dependent, traversed)),\r\n            directDependencies\r\n        )\r\n    }\r\n\r\n    hasDirectDependency(dependent: Sym, dependency: Sym) {\r\n        return this.dependencies.get(dependent)?.contains(dependency) || false\r\n    }\r\n\r\n    hasDependency(dependent: Sym, dependency: Sym) {\r\n        return this._hasDependency(dependent, dependency)\r\n    }\r\n\r\n    private _hasDependency(dependent: Sym, dependency: Sym, traversed = Set<Sym>()): boolean {\r\n        if (traversed.contains(dependent)) throw new Error('Infinite recursion error')\r\n        traversed = traversed.add(dependent)\r\n\r\n        const sym1Dependencies = this.dependencies.get(dependent, Set())\r\n\r\n        return (\r\n            sym1Dependencies.contains(dependency) ||\r\n            sym1Dependencies.some(sym => this._hasDependency(sym, dependency, traversed))\r\n        )\r\n    }\r\n\r\n    private normalize(dependent: Sym, dependency: Sym) {\r\n        const normalizedDownwards = this.normalizeDownwards(dependent, dependency, true)\r\n\r\n        return normalizedDownwards.getDirectDependents(dependent).reduce(\r\n            (graph: TermDependencyGraph, furtherDependent) =>\r\n                graph.normalizeDownwards(furtherDependent, dependency),\r\n            normalizedDownwards\r\n        )\r\n    }\r\n\r\n    private normalizeDownwards(\r\n        dependent: Sym,\r\n        dependency: Sym,\r\n        isRoot = false\r\n    ): TermDependencyGraph {\r\n        if (!isRoot && this.hasDirectDependency(dependent, dependency)) {\r\n            return this.removeDirectDependency(dependent, dependency)\r\n        }\r\n\r\n        return this.dependencies.get(dependency)?.reduce(\r\n            (graph: TermDependencyGraph, furtherDependency) =>\r\n                graph.normalizeDownwards(dependent, furtherDependency),\r\n            this\r\n        ) || this\r\n    }\r\n\r\n    private removeDirectDependency(dependent: Sym, dependency: Sym) {\r\n        const dependencyTerms = this.dependencies.get(dependent)\r\n        if (dependencyTerms === undefined) return this\r\n\r\n        const newDependencyTerms = dependencyTerms.remove(dependency)\r\n\r\n        return this.set(\r\n            'dependencies',\r\n            newDependencyTerms.isEmpty()\r\n                ? this.dependencies.remove(dependent)\r\n                : this.dependencies.set(dependent, newDependencyTerms)\r\n        )\r\n    }\r\n}\r\n\r\nexport abstract class TermDependencyGraphError extends BaseError {}\r\n\r\nexport class TermAlreadyUsedError extends TermDependencyGraphError {\r\n    constructor(readonly term: Sym) {\r\n        super(`term ${term} is already used`)\r\n    }\r\n}\r\n\r\nexport class CyclicDependenciesError extends TermDependencyGraphError {\r\n    constructor(\r\n        readonly dependentTerm: Sym,\r\n        readonly dependencyTerm: Sym\r\n    ) {\r\n        super(`term ${dependentTerm} forms a cycle by depending on ${dependencyTerm}`)\r\n    }\r\n}\r\n\r\n","/**\r\n * Base error of the whole project.\r\n *\r\n * Whenever we throw an error which should be caught, that error should inherit this base class.\r\n */\r\nexport abstract class BaseError extends Error {\r\n    constructor(message?: string) {\r\n        super(message)\r\n\r\n        // This might create problems if code is minified.\r\n        this.name = this.constructor.name\r\n    }\r\n}\r\n","import { List } from 'immutable'\r\nimport { connectWithBinarySym, Expression } from './abstract-structures/expression'\r\nimport { conjunction, implication } from './primitive-syms'\r\n\r\n/**\r\n * Create conjunction of `formulas`. If there's only one formula return it.\r\n */\r\nexport const createConjunction = (formulas: Expression[]): Expression =>\r\n    formulas.length === 1 ? formulas[0] : connectWithBinarySym(formulas, conjunction)\r\n\r\nexport const createImplicationWithAntecedentsAsConjunction = (\r\n    antecedents: Expression[],\r\n    consequent: Expression\r\n) => new Expression({\r\n    sym: implication,\r\n    children: List.of(\r\n        createConjunction(antecedents),\r\n        consequent\r\n    )\r\n})\r\n","export { DeductionInterface } from './deduction-interface'\r\n\r\nconst kita = 3\r\n\r\nmodule.exports = {\r\n    kita\r\n}\r\n","import { Set } from 'immutable'\r\nimport { Sym } from './abstract-structures/sym'\r\n\r\nexport const negation = Sym.ff({ id: 0, arity: 1 })\r\nexport const conjunction = Sym.ff({ id: 1, arity: 2 })\r\nexport const disjunction = Sym.ff({ id: 2, arity: 2 })\r\nexport const implication = Sym.ff({ id: 3, arity: 2 })\r\nexport const equivalence = Sym.ff({ id: 4, arity: 2 })\r\nexport const universalQuantifier = Sym.ff({ id: 5, arity: 1, binds: true })\r\nexport const existentialQuantifier = Sym.ff({ id: 6, arity: 1, binds: true })\r\n\r\nexport const primitiveSyms = Set.of<Sym>(\r\n    negation,\r\n    conjunction,\r\n    disjunction,\r\n    implication,\r\n    equivalence,\r\n    universalQuantifier,\r\n    existentialQuantifier\r\n)\r\n","import { List, Map } from 'immutable'\r\nimport { Sym } from '../abstract-structures/sym'\r\nimport { conjunction, disjunction, equivalence, implication, negation } from '../primitive-syms'\r\n\r\nexport type TruthTable = Map<List<boolean>, boolean>\r\n\r\nexport const primitiveTruthFunctions = Map<Sym, TruthTable>([\r\n    [\r\n        negation,\r\n        Map([\r\n            [List.of<boolean>(true), false],\r\n            [List.of<boolean>(false), true]\r\n        ] as [List<boolean>, boolean][])\r\n    ],\r\n    [\r\n        conjunction,\r\n        Map([\r\n            [List.of(true, true), true],\r\n            [List.of(true, false), false],\r\n            [List.of(false, true), false],\r\n            [List.of(false, false), false]\r\n        ] as [List<boolean>, boolean][])\r\n    ],\r\n    [\r\n        disjunction,\r\n        Map([\r\n            [List.of(true, true), true],\r\n            [List.of(true, false), true],\r\n            [List.of(false, true), true],\r\n            [List.of(false, false), false]\r\n        ] as [List<boolean>, boolean][])\r\n    ],\r\n    [\r\n        implication,\r\n        Map([\r\n            [List.of(true, true), true],\r\n            [List.of(true, false), false],\r\n            [List.of(false, true), true],\r\n            [List.of(false, false), true]\r\n        ] as [List<boolean>, boolean][])\r\n    ],\r\n    [\r\n        equivalence,\r\n        Map([\r\n            [List.of(true, true), true],\r\n            [List.of(true, false), false],\r\n            [List.of(false, true), false],\r\n            [List.of(false, false), true]\r\n        ] as [List<boolean>, boolean][])\r\n    ]\r\n] as [Sym, TruthTable][])\r\n","import { Map, Set } from 'immutable'\r\nimport { Expression } from '../abstract-structures/expression'\r\nimport { Sym } from '../abstract-structures/sym'\r\nimport { Category } from '../abstract-structures/sym/category'\r\nimport { BaseError } from '../error'\r\nimport { primitiveTruthFunctions } from './primitive-truth-functions'\r\n\r\nexport type Interpretation = Map<Sym, boolean>\r\n\r\nexport const evaluate = (\r\n    { sym, children }: Expression,\r\n    interpretation: Interpretation = Map()\r\n): boolean => {\r\n    if (sym.getCategory() !== Category.FF) throw new NotTruthFunctionalError()\r\n\r\n    if (sym.arity === 0) {\r\n        const value = interpretation.get(sym)\r\n        if (value === undefined) throw new NoAssignedValueError()\r\n        return value\r\n    }\r\n\r\n    const childrenValues = children.map(child => evaluate(child, interpretation))\r\n\r\n    return getTruthTable(sym).get(childrenValues)!\r\n}\r\n\r\n/**\r\n * Find all interpretations of `formula` which make the value of formula equal to `value`.\r\n */\r\nexport const findInterpretations = (formula: Expression, value: boolean) =>\r\n    findInterpretationsLimitedByBaseInterpretation(formula, value)\r\n\r\n/**\r\n * Find interpretations which are extensions of `interpretation`.\r\n */\r\nconst findInterpretationsLimitedByBaseInterpretation = (\r\n    { sym, children }: Expression,\r\n    value: boolean,\r\n    interpretation: Interpretation = Map()\r\n): Set<Interpretation> => {\r\n    if (sym.getCategory() !== Category.FF || sym.binds) {\r\n        throw new NotTruthFunctionalError()\r\n    }\r\n\r\n    if (sym.arity === 0) {\r\n        const fixedValue = interpretation.get(sym)\r\n        if (fixedValue !== undefined) return fixedValue !== value ? Set() : Set.of(interpretation)\r\n        return Set.of(interpretation.set(sym, value))\r\n    }\r\n\r\n    return getTruthTable(sym)\r\n        .entrySeq()\r\n        .filter(([, tableValue]) => tableValue === value)\r\n        .map(([tableArgs]) => tableArgs)\r\n        .map(tableArgs => children.reduce(\r\n            (interpretations, child, i) => findInterpretationsLimitedByBaseInterpretations(\r\n                child,\r\n                tableArgs.get(i)!,\r\n                interpretations\r\n            ),\r\n            Set.of(interpretation)\r\n        ))\r\n        .reduce((result, interpretations) => result.union(interpretations), Set())\r\n}\r\n\r\n/**\r\n * Find interpretations which are extensions of `interpretations`.\r\n */\r\nconst findInterpretationsLimitedByBaseInterpretations = (\r\n    formula: Expression,\r\n    value: boolean,\r\n    interpretations: Set<Interpretation>\r\n) =>\r\n    interpretations.reduce(\r\n        (result, interpretation) => result.union(\r\n            findInterpretationsLimitedByBaseInterpretation(formula, value, interpretation)\r\n        ),\r\n        Set<Interpretation>()\r\n    )\r\n\r\n\r\nconst getTruthTable = (sym: Sym) => {\r\n    const truthFunction = primitiveTruthFunctions.get(sym)\r\n    if (truthFunction === undefined) throw new NoAssignedValueError()\r\n    return truthFunction\r\n}\r\n\r\nexport abstract class EvaluationError extends BaseError {}\r\n\r\nexport class NotTruthFunctionalError extends EvaluationError {}\r\n\r\nexport class NoAssignedValueError extends EvaluationError {}\r\n","import { List } from 'immutable'\r\nimport { Expression } from '../abstract-structures/expression'\r\nimport { createImplicationWithAntecedentsAsConjunction } from '../formula-construction-util'\r\nimport { implication } from '../primitive-syms'\r\nimport * as util from './propositional-logic-util'\r\nimport { reduceToTruthFunctional } from './reduce-to-truth-functional'\r\n\r\nexport const isSatisfiable = (formula: Expression) => hasInterpretations(formula, true)\r\n\r\nexport const isFalsifiable = (formula: Expression) => hasInterpretations(formula, false)\r\n\r\nexport const isContingent = (formula: Expression) =>\r\n    isSatisfiable(formula) && isFalsifiable(formula)\r\n\r\nexport const isTautology = (formula: Expression) => !isFalsifiable(formula)\r\n\r\nexport const isContradiction = (formula: Expression) => !isSatisfiable(formula)\r\n\r\nexport const isLogicalConsequence = (assumptions: Expression[], consequence: Expression) => {\r\n    if (assumptions.length === 0) return isTautology(consequence)\r\n    if (assumptions.length === 1) {\r\n        return isTautology(\r\n            new Expression({\r\n                sym: implication,\r\n                children: List.of(assumptions[0], consequence)\r\n            })\r\n        )\r\n    }\r\n    return isTautology(\r\n        createImplicationWithAntecedentsAsConjunction(assumptions, consequence)\r\n    )\r\n}\r\n\r\nconst hasInterpretations = (formula: Expression, value: boolean) =>\r\n    !findInterpretations(formula, value).isEmpty()\r\n\r\nconst findInterpretations = (formula: Expression, value: boolean) => {\r\n    const reducedFormula = reduceToTruthFunctional(formula)\r\n    return util.findInterpretations(reducedFormula, value)\r\n}\r\n","import { List, Map } from 'immutable'\r\nimport { Expression } from '../abstract-structures/expression'\r\nimport { Sym } from '../abstract-structures/sym'\r\nimport { Category } from '../abstract-structures/sym/category'\r\n\r\n/**\r\n * Traverse `formula` and replace each non-truth-functional subformula with a generated\r\n * truth-functional symbol using successive negative ids (to avoid collision with existing symbols).\r\n * This is a mid-step before doing truth-functional operations on any formula.\r\n */\r\nexport const reduceToTruthFunctional = (formula: Expression) =>\r\n    reduceToTruthFunctionalWithSubstitutions(formula)[0]\r\n\r\nconst reduceToTruthFunctionalWithSubstitutions = (\r\n    formula: Expression,\r\n    substitutions: Substitutions = Map()\r\n): readonly [Expression, Substitutions] => {\r\n    const { sym, children } = formula\r\n\r\n    if (sym.getCategory() === Category.FF && !sym.binds) {\r\n        const [newChildren, newAssignments] = children\r\n            .reduce(([currentChildren, currentAssignments], child) => {\r\n                const [\r\n                    newChild,\r\n                    newAssignments\r\n                ] = reduceToTruthFunctionalWithSubstitutions(child, currentAssignments)\r\n                return [currentChildren.push(newChild), newAssignments]\r\n            }, [List(), substitutions])\r\n\r\n        return [new Expression({ sym, children: newChildren }), newAssignments]\r\n    }\r\n\r\n    let assignmentsToReturn = substitutions\r\n\r\n    let substitutedSym = substitutions.get(formula)\r\n    if (substitutedSym === undefined) {\r\n        substitutedSym = Sym.ff({ id: -assignmentsToReturn.size })\r\n        assignmentsToReturn = assignmentsToReturn.set(formula, substitutedSym)\r\n    }\r\n\r\n    return [new Expression({ sym: substitutedSym }), assignmentsToReturn]\r\n}\r\n\r\ntype Substitutions = Map<Expression, Sym>\r\n","module.exports = __WEBPACK_EXTERNAL_MODULE_immutable__;"],"sourceRoot":""}